/*	SCCS Id: @(#)end.c	3.4	2003/03/10	*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* NetHack may be freely redistributed.  See license for details. */

#define NEED_VARARGS	/* comment line for pre-compiled headers */

#include "hack.h"

#ifndef NO_SIGNAL
#include <signal.h>
#endif
#include "dlb.h"
#ifdef UNIX /* DUMP-patch dump filename chmod() */
#include <sys/types.h>
#include <sys/stat.h>
#endif

	/* these probably ought to be generated by makedefs, like LAST_GEM */
#define FIRST_GEM    MAGICITE_CRYSTAL
#define FIRST_AMULET AMULET_OF_ESP
#define LAST_AMULET  AMULET_OF_YENDOR
 
struct valuable_data { long count; int typ; };

static struct valuable_data
	gems[LAST_GEM+1 - FIRST_GEM + 1], /* 1 extra for glass */
	amulets[LAST_AMULET+1 - FIRST_AMULET];

static struct val_list { struct valuable_data *list; int size; } valuables[] = {
	{ gems,    sizeof gems / sizeof *gems },
	{ amulets, sizeof amulets / sizeof *amulets },
	{ 0, 0 }
};

#ifndef NO_SIGNAL
STATIC_PTR void FDECL(done_intr, (int));
# if defined(UNIX) || defined(VMS) || defined (__EMX__)
static void FDECL(done_hangup, (int));
# endif
#endif
STATIC_DCL void FDECL(disclose,(int,BOOLEAN_P));
STATIC_DCL void FDECL(get_valuables, (struct obj *));
STATIC_DCL void FDECL(sort_valuables, (struct valuable_data *,int));
STATIC_DCL void FDECL(artifact_score, (struct obj *,BOOLEAN_P,winid));
STATIC_DCL void FDECL(savelife, (int));
void FDECL(list_vanquished, (CHAR_P,BOOLEAN_P));
#ifdef DUMP_LOG
extern char msgs[][BUFSZ];
extern int lastmsg;
extern void NDECL(dump_spells);
void FDECL(do_vanquished, (int, BOOLEAN_P, BOOLEAN_P));
STATIC_DCL void FDECL(list_genocided, (int, BOOLEAN_P, BOOLEAN_P));
#else
STATIC_DCL void FDECL(list_genocided, (CHAR_P,BOOLEAN_P));
#endif /* DUMP_LOG */
STATIC_DCL boolean FDECL(should_query_disclose_option, (int,char *));

#if defined(__BEOS__) || defined(MICRO) || defined(WIN32) || defined(OS2)
extern void FDECL(nethack_exit,(int));
#else
#define nethack_exit exit
#endif

#define done_stopprint program_state.stopprint

#ifdef AMIGA
# define NH_abort()	Abort(0)
#else
# ifdef SYSV
# define NH_abort()	(void) abort()
# else
#  ifdef WIN32
# define NH_abort()	win32_abort()
#  else
# define NH_abort()	abort()
#  endif
# endif
#endif

/*
 * The order of these needs to match the macros in hack.h.
 */
static NEARDATA const char *deaths[] = {		/* the array of death */
	"died", "betrayed", "choked", "poisoned", "starvation", "drowning", /*5*/
	"burning", "dissolving under the heat and pressure",
	"crushed", "turned to stone", "turned to gold", "turned to glass", "turned into slime",
	"exploded after being overwound", "turned into a weeping angel", "disintegrated",
	"genocided",
	"panic", "trickery",
	"quit", "escaped", "ascended"
};

static NEARDATA const char *ends[] = {		/* "when you..." */
	"died", "were betrayed", "choked", "were poisoned", "starved", "drowned",
	"burned", "dissolved in the lava",
	"were crushed", "turned to stone", "turned to gold", "turned to glass", "turned into slime",
	"were overwound and exploded", "turned into a weeping angel", "were disintegrated",
	"were genocided",
	"panicked", "were tricked",
	"quit", "escaped", "ascended"
};

extern const char * const killed_by_prefix[];	/* from topten.c */

char *
dump_format_str(char *str)
{
    static char buf[512];
    char *f, *p, *end;
    int ispercent = 0;

    buf[0] = '\0';

    if (!str) return NULL;

    f = str;
    p = buf;
    end = buf + sizeof(buf) - 10;

    while (*f) {
      if (ispercent) {
	switch (*f) {
	case 't':
	  snprintf (p, end + 1 - p, "%ld", u.ubirthday);
	  while (*p != '\0')
	    p++;
	  break;
        case 'N':
          *p = plname[0];
	  p++;
	  *p = '\0';
	  break;
	case 'n':
	  snprintf (p, end + 1 - p, "%s", plname);
	  while (*p != '\0')
	    p++;
	  break;
	default:
	  *p = *f;
	  if (p < end)
	    p++;
	}
	ispercent = 0;
      } else {
	if (*f == '%')
	  ispercent = 1;
	else {
	  *p = *f;
	  if (p < end)
	    p++;
	}
      }
      f++;
    }
    *p = '\0';

    return buf;
}



#ifdef DUMP_LOG
FILE *dump_fp = (FILE *)0;  /* file pointer for dumps */
/* functions dump_init, dump_exit and dump are from the dump patch */

void
dump_init ()
{
  if (dump_fn[0]) {
#ifdef UNIX
    mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif
    char new_dump_fn[512];
    Sprintf(new_dump_fn, "%s", dump_format_str(dump_fn));

    dump_fp = fopen (new_dump_fn, "w");
    if (!dump_fp) {
      pline("Can't open %s for output.", new_dump_fn);
      pline("Dump file not created.");
      return;
    }
#if defined(UNIX)
    chmod(new_dump_fn, dumpmode);
#endif
  }
}

void
dump_exit ()
{
  if (dump_fp)
    fclose (dump_fp);
}


void
mk_dgl_extrainfo()
{
#ifdef EXTRAINFO_FN
    FILE *extrai = (FILE *)0;
#ifdef UNIX
    mode_t eimode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif
    char new_fn[512];

    Sprintf(new_fn, "%s", dump_format_str(EXTRAINFO_FN));

    extrai = fopen(new_fn, "w");
    if (!extrai) {
    } else {
	int sortval = 0;
	char tmpdng[16];
	sortval += (u.uhave.amulet ? 1024 : 0);
	if (Is_knox(&u.uz)) {
	    Sprintf(tmpdng, "%s", "Knx");
	    sortval += 245;
	} else if (In_quest(&u.uz)) {
	    Sprintf(tmpdng, "%s%i", "Q", dunlev(&u.uz));
	    sortval += 250+(dunlev(&u.uz));
	} else if (In_endgame(&u.uz)) {
	    Sprintf(tmpdng, "%s", "End");
	    sortval += 256;
	} else if (In_tower(&u.uz)) {
	    Sprintf(tmpdng, "T%i", dunlev(&u.uz));
	    sortval += 235+(depth(&u.uz));
	} else if (In_sokoban(&u.uz)) {
	    Sprintf(tmpdng, "S%i", dunlev(&u.uz));
	    sortval += 225+(depth(&u.uz));
	} else if (In_mines(&u.uz)) {
	    Sprintf(tmpdng, "M%i", dunlev(&u.uz));
	    sortval += 215+(dunlev(&u.uz));
	} else {
	    Sprintf(tmpdng, "D%i", depth(&u.uz));
	    sortval += (depth(&u.uz));
	}
#ifdef UNIX
	chmod(new_fn, eimode);
#endif
	fprintf(extrai, "%i|%c %s", sortval, (u.uhave.amulet ? 'A' : ' '), tmpdng);
	fclose(extrai);
    }
#endif /* EXTRAINFO_FN */
}

void
mk_mapdump(char *fname)
{
  if (fname[0]) {
#ifdef UNIX
    mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif
    char new_dump_fn[512];
    Sprintf(new_dump_fn, "%s", dump_format_str(fname));

    dump_fp = fopen(new_dump_fn, "w");
    if (!dump_fp) {
      pline("Can't open %s for output.", new_dump_fn);
      pline("Dump file not created.");
    } else {
#ifdef UNIX
	chmod(new_dump_fn, dumpmode);
#endif
	dump_screen(1);
	dump_exit();
    }
  }
}

void dump (pre, str)
     char *pre, *str;
{
  if (dump_fp)
    fprintf (dump_fp, "%s%s\n", pre, str);
}
#endif  /* DUMP_LOG */

/*ARGSUSED*/
void
done1(sig_unused)   /* called as signal() handler, so sent at least one arg */
int sig_unused;
{
#ifndef NO_SIGNAL
	(void) signal(SIGINT,SIG_IGN);
#endif
	if(flags.ignintr) {
#ifndef NO_SIGNAL
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif
		clear_nhwindow(WIN_MESSAGE);
		curs_on_u();
		wait_synch();
		if(multi > 0) nomul(0, NULL);
	} else {
		(void)done2();
	}
}


/* "#quit" command or keyboard interrupt */
int
done2()
{
	if (iflags.debug_fuzzer)
		return 0;
#ifdef PARANOID
	char buf[BUFSZ];
	int really_quit = FALSE;

	if (iflags.paranoid_quit) {
	  getlin ("Really quit [yes/no]?",buf);
	  (void) lcase (buf);
	  if (!(strcmp (buf, "yes"))) really_quit = TRUE;
	} else {
	  if(yn("Really quit?") == 'y') really_quit = TRUE;
	}
	if (!really_quit) {
#else /* PARANOID */
	if(yn("Really quit?") == 'n') {
#endif /* PARANOID */
#ifndef NO_SIGNAL
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif
		clear_nhwindow(WIN_MESSAGE);
		curs_on_u();
		wait_synch();
		if(multi > 0) nomul(0, NULL);
		if(multi == 0) {
		    u.uinvulnerable = FALSE;	/* avoid ctrl-C bug -dlc */
		    u.usleep = 0;
		}
		return 0;
	}
#if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
	if(wizard) {
	    int c;
# ifdef VMS
	    const char *tmp = "Enter debugger?";
# else
#  ifdef LATTICE
	    const char *tmp = "Create SnapShot?";
#  else
	    const char *tmp = "Dump core?";
#  endif
# endif
	    if ((c = ynq(tmp)) == 'y') {
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
		exit_nhwindows((char *)0);
		NH_abort();
	    } else if (c == 'q') done_stopprint++;
	}
#endif
#ifndef LINT
	done(QUIT);
#endif
	return 0;
}

#ifndef NO_SIGNAL
/*ARGSUSED*/
STATIC_PTR void
done_intr(sig_unused) /* called as signal() handler, so sent at least one arg */
int sig_unused;
{
	done_stopprint++;
	(void) signal(SIGINT, SIG_IGN);
# if defined(UNIX) || defined(VMS)
	(void) signal(SIGQUIT, SIG_IGN);
# endif
	return;
}

# if defined(UNIX) || defined(VMS) || defined(__EMX__)
static void
done_hangup(sig)	/* signal() handler */
int sig;
{
	program_state.done_hup++;
	(void)signal(SIGHUP, SIG_IGN);
	done_intr(sig);
	return;
}
# endif
#endif /* NO_SIGNAL */

void
done_in_by(mtmp)
register struct monst *mtmp;
{
	char buf[BUFSZ];
	boolean distorted = (boolean)(Hallucination && canspotmon(mtmp));

	You("die...");
	mark_synch();	/* flush buffered screen output */
	buf[0] = '\0';
	killer_format = KILLED_BY_AN;
	/* "killed by the high priest of Crom" is okay, "killed by the high
	   priest" alone isn't */
	if ((mtmp->data->geno & G_UNIQ) != 0 && !( (mtmp->mtyp == PM_HIGH_PRIEST || 
												mtmp->mtyp == PM_ELDER_PRIEST) && !mtmp->ispriest)) {
	    if (!type_is_pname(mtmp->data))
		Strcat(buf, "the ");
	    killer_format = KILLED_BY;
	}
	/* _the_ <invisible> <distorted> ghost of Dudley */
	if ((mtmp->mtyp == PM_GHOST || mtmp->mtyp == PM_SHADE || mtmp->mtyp == PM_BROKEN_SHADOW) && M_HAS_NAME(mtmp)) {
		Strcat(buf, "the ");
		killer_format = KILLED_BY;
	}
	if (mtmp->minvis)
		Strcat(buf, "invisible ");
	if (distorted)
		Strcat(buf, "hallucinogen-distorted ");

	if(mtmp->mtyp == PM_GHOST) {
		Strcat(buf, "ghost");
		if (M_HAS_NAME(mtmp)) Sprintf(eos(buf), " of %s", MNAME(mtmp));
	} else if(mtmp->mtyp == PM_BROKEN_SHADOW) {
		Strcat(buf, "broken shadow");
		if (M_HAS_NAME(mtmp)) Sprintf(eos(buf), " of %s", MNAME(mtmp));
	} else if(mtmp->mtyp == PM_SHADE) {
		Strcat(buf, "shade");
		if (M_HAS_NAME(mtmp)) Sprintf(eos(buf), " of %s", MNAME(mtmp));
	} else if(mtmp->isshk) {
		Sprintf(eos(buf), "%s %s, the shopkeeper",
			(mtmp->female ? "Ms." : "Mr."), shkname(mtmp));
		killer_format = KILLED_BY;
		if (templated(mtmp))
			append_template_desc(mtmp, buf, TRUE);
	} else if (get_mx(mtmp, MX_EPRI) || get_mx(mtmp, MX_EMIN)) {
		/* m_monnam() suppresses "the" prefix plus "invisible", and
		   it overrides the effect of Hallucination on priestname() */
		killer = m_monnam(mtmp);
		Strcat(buf, killer);
		if (templated(mtmp))
			append_template_desc(mtmp, buf, type_is_pname(mtmp->data));
	} else {
		Strcat(buf, mtmp->data->mname);
		if (templated(mtmp))
			append_template_desc(mtmp, buf, type_is_pname(mtmp->data));
		if (M_HAS_NAME(mtmp))
		    Sprintf(eos(buf), " called %s", MNAME(mtmp));
	}

	if (multi) {
	    if (strlen(multi_txt) > 0)
		Sprintf(eos(buf), ", while %s", multi_txt);
	    else
		Strcat(buf, ", while helpless");
	}
	killer = buf;
	if(!uclockwork && !uandroid && !nonliving(youracedata)){
		if (mtmp->data->mlet == S_WRAITH)
			u.ugrave_arise = PM_WRAITH;
		else if (mtmp->mtyp == PM_SHADE)
			u.ugrave_arise = PM_SHADE;
		else if (mtmp->mtyp == PM_BROKEN_SHADOW)
			u.ugrave_arise = PM_BROKEN_SHADOW;
		else if (mtmp->data->mlet == S_MUMMY && urace.mummynum != NON_PM)
			u.ugrave_arise = urace.mummynum;
		else if ((mtmp->data->mlet == S_VAMPIRE || has_template(mtmp, VAMPIRIC)) && (Race_if(PM_HUMAN) || Race_if(PM_INHERITOR)))
			u.ugrave_arise = PM_VAMPIRE;
		else if (mtmp->mtyp == PM_GHOUL || mtmp->mtyp == PM_GNOLL_GHOUL)
			u.ugrave_arise = PM_GHOUL;
		else if (mtmp->mtyp == PM_DREADBLOSSOM_SWARM)
			u.ugrave_arise = PM_DREADBLOSSOM_SWARM;
		else if (mtmp->mtyp == PM_DREAD_SERAPH || has_template(mtmp, SKELIFIED))
			u.ugrave_arise = PM_SKELETON;
		else if (mtmp->data->mlet == S_ZOMBIE || has_template(mtmp, ZOMBIFIED))
			u.ugrave_arise = PM_ZOMBIE;
		else if (mtmp->mtyp == PM_ANCIENT_OF_CORRUPTION || has_template(mtmp, SLIME_REMNANT))
			u.ugrave_arise = PM_ANCIENT_OF_CORRUPTION;
		else if (mtmp->mtyp == PM_BAALPHEGOR || has_template(mtmp, CRYSTALFIED))
			u.ugrave_arise = PM_BAALPHEGOR;
	} else if(uandroid){
		if (mtmp->mtyp == PM_BROKEN_SHADOW)
			u.ugrave_arise = PM_BROKEN_SHADOW;
		else if (mtmp->data->mlet == S_MUMMY && urace.mummynum != NON_PM)
			u.ugrave_arise = urace.mummynum;
		// else if (mtmp->data->mlet == S_VAMPIRE || has_template(mtmp, VAMPIRIC))
			// u.ugrave_arise = PM_VAMPIRIC_DOLL;
		else if (mtmp->mtyp == PM_DREAD_SERAPH || has_template(mtmp, SKELIFIED))
			u.ugrave_arise = PM_FLAYED_ANDROID;
		else if (mtmp->data->mlet == S_ZOMBIE || has_template(mtmp, ZOMBIFIED))
			u.ugrave_arise = PM_FLAYED_ANDROID;
		else if (mtmp->mtyp == PM_BAALPHEGOR || has_template(mtmp, CRYSTALFIED))
			u.ugrave_arise = PM_BAALPHEGOR;
	} else { //clockwork or other nonliving
		if (mtmp->mtyp == PM_BROKEN_SHADOW)
			u.ugrave_arise = PM_BROKEN_SHADOW;
		else if (mtmp->mtyp == PM_DREADBLOSSOM_SWARM && !uclockwork && !is_naturally_unalive(youracedata))
			u.ugrave_arise = PM_DREADBLOSSOM_SWARM;
		else if (mtmp->mtyp == PM_BAALPHEGOR || has_template(mtmp, CRYSTALFIED))
			u.ugrave_arise = PM_BAALPHEGOR;
	}
	if (u.ugrave_arise >= LOW_PM &&
				(mvitals[u.ugrave_arise].mvflags & G_GENOD && !In_quest(&u.uz)))
		u.ugrave_arise = NON_PM;
	if (touch_petrifies(mtmp->data))
		done(STONING);
	else if (mtmp->mtraitor)
		done(BETRAYED);
	else
		done(DIED);
	return;
}

#if defined(WIN32)
#define NOTIFY_NETHACK_BUGS
#endif

/*VARARGS1*/
void
panic VA_DECL(const char *, str)
	VA_START(str);
	VA_INIT(str, char *);
	/*The actual panic code is too prone to shredding games*/
	/* Just print out the error message and abort.*/
	raw_print("\nIt seems the game has suffered a fatal panic attack.");
	raw_printf("Report the following error to the developer: %s", str);
	{
	    char buf[BUFSZ];
	    Vsprintf(buf,str,VA_ARGS);
	    raw_print(buf);
	    paniclog("panic", buf);
	}
	NH_abort(); /*actually just die here*/
}

STATIC_OVL boolean
should_query_disclose_option(category, defquery)
int category;
char *defquery;
{
    int idx;
    char *dop = index(disclosure_options, category);

    if (dop && defquery) {
	idx = dop - disclosure_options;
	if (idx < 0 || idx > (NUM_DISCLOSURE_OPTIONS - 1)) {
	    impossible(
		   "should_query_disclose_option: bad disclosure index %d %c",
		       idx, category);
	    *defquery = DISCLOSE_PROMPT_DEFAULT_YES;
	    return TRUE;
	}
	if (flags.end_disclose[idx] == DISCLOSE_YES_WITHOUT_PROMPT) {
	    *defquery = 'y';
	    return FALSE;
	} else if (flags.end_disclose[idx] == DISCLOSE_NO_WITHOUT_PROMPT) {
	    *defquery = 'n';
	    return FALSE;
	} else if (flags.end_disclose[idx] == DISCLOSE_PROMPT_DEFAULT_YES) {
	    *defquery = 'y';
	    return TRUE;
	} else if (flags.end_disclose[idx] == DISCLOSE_PROMPT_DEFAULT_NO) {
	    *defquery = 'n';
	    return TRUE;
	}
    }
    if (defquery)
	impossible("should_query_disclose_option: bad category %c", category);
    else
	impossible("should_query_disclose_option: null defquery");
    return TRUE;
}

STATIC_OVL void
disclose(how,taken)
int how;
boolean taken;
{
	char	c = 0, defquery;
	char	qbuf[QBUFSZ];
	boolean ask;

	if (invent) {
	    if(taken)
		Sprintf(qbuf,"Do you want to see what you had when you %s?",
			(how == QUIT) ? "quit" : "died");
	    else
		Strcpy(qbuf,"Do you want your possessions identified?");

	    ask = should_query_disclose_option('i', &defquery);
	    if (!done_stopprint) {
		c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
	    } else {
		c = 'n';
	    }
		{
#ifdef DUMP_LOG
			boolean want_disp = (c == 'y')? TRUE: FALSE;
#endif
			struct obj *obj;

			for (obj = invent; obj; obj = obj->nobj) {
			    makeknown(obj->otyp);
			    obj->known = obj->bknown = obj->dknown = obj->rknown = obj->sknown = 1;
				if (obj->oartifact) discover_artifact(obj->oartifact);
			}
#ifdef DUMP_LOG
			(void) dump_inventory((char *)0, TRUE, want_disp);
			do_containerconts(invent, TRUE, TRUE, TRUE, want_disp);
#else
			if (c == 'y') {
			(void) display_inventory((char *)0, TRUE);
			container_contents(invent, TRUE, TRUE);
		}
#endif /* DUMP_LOG */
	    }
		if (c == 'q')  done_stopprint++;
	}

	ask = should_query_disclose_option('a', &defquery);
	if (!done_stopprint) {
	    c = ask ? yn_function("Do you want to see your attributes?",
				  ynqchars, defquery) : defquery;
	    if (c == 'y')
		enlightenment(how >= PANICKED ? 1 : 2); /* final */
	    if (c == 'q') done_stopprint++;
	}
#ifdef DUMP_LOG
	if (dump_fp) {
	  dump_enlightenment((int) (how >= PANICKED ? 1 : 2));
	  dump_spells();
	}
#endif

	ask = should_query_disclose_option('v', &defquery);
#ifdef DUMP_LOG
	do_vanquished(defquery, ask, TRUE);
#else
	if (!done_stopprint)
	    list_vanquished(defquery, ask);
#endif

	ask = should_query_disclose_option('g', &defquery);
	if (!done_stopprint)
#ifdef DUMP_LOG
	    list_genocided(defquery, ask,TRUE);
#else
	    list_genocided(defquery, ask);
#endif

	ask = should_query_disclose_option('c', &defquery);
	if (!done_stopprint) {
	    c = ask ? yn_function("Do you want to see your conduct?",
				  ynqchars, defquery) : defquery;
	    if (c == 'y')
		show_conduct(how >= PANICKED ? 1 : 2);
	    if (c == 'q') done_stopprint++;
	}
#ifdef DUMP_LOG
	if (dump_fp) {
	    dump_conduct(how >= PANICKED ? 1 : 2);
	    dump_weapon_skill();
	}
#endif
}

/* try to get the player back in a viable state after being killed */
STATIC_OVL void
savelife(how)
int how;
{
	u.uswldtim = 0;
	u.divetimer = ACURR(A_CON)/3;
	u.uhp = u.uhpmax;
	u.mh = u.mhmax;
	if (YouHunger < 500) {
		if(Race_if(PM_INCANTIFIER)) u.uen = u.uenmax/4;
		else u.uhunger = 500;
	    newuhs(FALSE);
	}
	/* cure impending doom of sickness hero won't have time to fix */
	if ((Sick & TIMEOUT) == 1) {
	    u.usick_type = 0;
	    Sick = 0;
	}
	if (how == CHOKING) {
		reset_uhunger();
		HStrangled &= ~TIMEOUT;
		delayed_killer = 0;
	}
	nomovemsg = "You survived that attempt on your life.";
	flags.move = 0;
	if(multi > 0) multi = 0; else multi = -1;
	if(u.utrap && u.utraptype == TT_LAVA) u.utrap = 0;
	flags.botl = 1;
	u.ugrave_arise = NON_PM;
	curs_on_u();
}

/*
 * Get valuables from the given list.  Revised code: the list always remains
 * intact.
 */
STATIC_OVL void
get_valuables(list)
struct obj *list;	/* inventory or container contents */
{
    register struct obj *obj;
    register int i;

    /* find amulets and gems, ignoring all artifacts */
    for (obj = list; obj; obj = obj->nobj)
	if (Has_contents(obj)) {
	    get_valuables(obj->cobj);
	} else if (obj->oartifact) {
	    continue;
	} else if (obj->oclass == AMULET_CLASS) {
	    i = obj->otyp - FIRST_AMULET;
	    if (!amulets[i].count) {
		amulets[i].count = obj->quan;
		amulets[i].typ = obj->otyp;
	    } else amulets[i].count += obj->quan; /* always adds one */
	} else if (obj->oclass == GEM_CLASS && obj->otyp < LUCKSTONE) {
	    i = min(obj->otyp, LAST_GEM + 1) - FIRST_GEM;
	    if (!gems[i].count) {
		gems[i].count = obj->quan;
		gems[i].typ = obj->otyp;
	    } else gems[i].count += obj->quan;
	}
    return;
}

/*
 *  Sort collected valuables, most frequent to least.  We could just
 *  as easily use qsort, but we don't care about efficiency here.
 */
STATIC_OVL void
sort_valuables(list, size)
struct valuable_data list[];
int size;		/* max value is less than 20 */
{
    register int i, j;
    struct valuable_data ltmp;

    /* move greater quantities to the front of the list */
    for (i = 1; i < size; i++) {
	if (list[i].count == 0) continue;	/* empty slot */
	ltmp = list[i]; /* structure copy */
	for (j = i; j > 0; --j)
	    if (list[j-1].count >= ltmp.count) break;
	    else {
		list[j] = list[j-1];
	    }
	list[j] = ltmp;
    }
    return;
}

/* called twice; first to calculate total, then to list relevant items */
STATIC_OVL void
artifact_score(list, counting, endwin)
struct obj *list;
boolean counting;	/* true => add up points; false => display them */
winid endwin;
{
    char pbuf[BUFSZ];
    struct obj *otmp;
    long value, points;

    for (otmp = list; otmp; otmp = otmp->nobj) {
	if (otmp->oartifact ||
			otmp->otyp == BELL_OF_OPENING ||
			otmp->otyp == SPE_BOOK_OF_THE_DEAD ||
			otmp->otyp == CANDELABRUM_OF_INVOCATION) {
	    value = arti_cost(otmp);	/* zorkmid value */
	    points = value * 5 / 2;	/* score value */
	    if (counting) {
		u.urexp += points;
	    } else {
		makeknown(otmp->otyp);
		otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = otmp->sknown = 1;
		/* assumes artifacts don't have quan > 1 */
		Sprintf(pbuf, "%s%s (worth %ld %s and %ld points)",
			the_unique_obj(otmp) ? "The " : "",
			otmp->oartifact ? artiname(otmp->oartifact) :
				OBJ_NAME(objects[otmp->otyp]),
			value, currency(value), points);
#ifdef DUMP_LOG
		if (dump_fp)
		  dump("", pbuf);
		if (endwin != WIN_ERR)
#endif
		putstr(endwin, 0, pbuf);
	    }
	}
	if (Has_contents(otmp) 
		&& !(is_lightsaber(otmp) && otmp->cobj->oartifact == otmp->oartifact)	/* lightsabers inherit their gem's oartifact */
		) {
	    artifact_score(otmp->cobj, counting, endwin);
	}
    }
}

struct obj *
find_equip_life_oprop()
{
	struct obj *otmp;
	for(otmp = invent; otmp; otmp = otmp->nobj){
		if(otmp->owornmask && check_oprop(otmp, OPROP_LIFE))
			return otmp;
	}
	return (struct obj *) 0;
}

/* Be careful not to call panic from here! */
void
done(how)
int how;
{
#if defined(WIZARD) && defined(PARANOID)
	char paranoid_buf[BUFSZ];
	int really_bon = TRUE;
#endif
	boolean taken;
	char kilbuf[BUFSZ], pbuf[BUFSZ];
	winid endwin = WIN_ERR;
	boolean bones_ok, have_windows = iflags.window_inited;
	struct obj *corpse = (struct obj *)0;
	long umoney;
	int i;
	int lsvd;
	struct obj *otmp;

	if (how == TRICKED) {
		abort();
	    if (killer) {
		paniclog("trickery", killer);
		killer = 0;
	    }
#ifdef WIZARD
	    if (wizard) {
		You("are a very tricky wizard, it seems.");
		return;
	    }
#endif
	}
		
	if (iflags.debug_fuzzer) {
	        if (!(program_state.panicking || how == PANICKED)) {
	            savelife(how);
	            /* periodically restore characteristics and lost exp levels
	               or cure lycanthropy */
	            if (!rn2(10)) {
	                struct obj *potion = mksobj((u.ulycn > LOW_PM && !rn2(3))
	                                            ? POT_WATER : POT_RESTORE_ABILITY,
	                                            NO_MKOBJ_FLAGS);
	
	                bless(potion);
	                (void) peffects(potion); /* always -1 for restore ability */
	                /* not useup(); we haven't put this potion into inventory */
	                obfree(potion, (struct obj *) 0);
	            }
	            killer = 0;
	            killer_format = 0;
	            return;
	        }
	    } else


	/* kilbuf: used to copy killer in case it comes from something like
	 *	xname(), which would otherwise get overwritten when we call
	 *	xname() when listing possessions
	 * pbuf: holds Sprintf'd output for raw_print and putstr
	 */
	if (how == ASCENDED || (!killer && how == GENOCIDED))
		killer_format = NO_KILLER_PREFIX;
	/* Avoid killed by "a" burning or "a" starvation */
	if (!killer && (how == STARVING || how == BURNING))
		killer_format = KILLED_BY;
	Strcpy(kilbuf, (!killer || how >= PANICKED ? deaths[how] : killer));
	killer = kilbuf;

#define LSVD_NONE 0
#define LSVD_MISC 1
#define LSVD_JACK 2
#define LSVD_DTHK 3

	if (how < PANICKED) u.umortality++;
	if (Lifesaved && (how <= GENOCIDED)) {
		pline("But wait...");
		if(uarmh && uarmh->oartifact == ART_HELM_OF_UNDEATH) {
			otmp = uarmh;
			if (!(
					((mvitals[PM_DEATH_KNIGHT].mvflags & G_GENOD) && !In_quest(&u.uz)) ||/* G_EXTINCT okay */
					(Unchanging) ||
					is_undead(youracedata)
				)) {
				You_feel("a curse fall upon your soul!");
				if (Upolyd && uskin && uskin->oartifact == ART_MIRRORED_MASK) {
					pline("Your mask falls to pieces!");
					useup(uskin);
				}
				polymon(PM_DEATH_KNIGHT);
				HUnchanging |= FROMOUTSIDE;
				lsvd = LSVD_DTHK;
			}
			else {
				You_feel("oddly invigorated, and you %s!",
					how == DISINTEGRATED ? "reconstitute" :
					how == OVERWOUND ? "reassemble" :
					"feel much better"
					);
				lsvd = LSVD_MISC;
			}
			Your("helmet crumbles to dust!");
			if (otmp->where == OBJ_INVENT)
				useup(otmp);
			else {
				obj_extract_self(otmp);
				obfree(otmp, (struct obj *)0);
			}
		}
		else if(uamul && uamul->otyp == AMULET_OF_LIFE_SAVING){
			if(!check_oprop(uamul, OPROP_LIFE))
				makeknown(AMULET_OF_LIFE_SAVING);

			Your("medallion %s!",
				  !Blind ? "begins to glow" : "feels warm");
			if (how == CHOKING) You("vomit ...");
			if (how == DISINTEGRATED) You("reconstitute!");
			else if (how == OVERWOUND) You("reassemble!");
			else You_feel("much better!");

			lsvd = LSVD_MISC;
			if(!check_oprop(uamul, OPROP_LIFE)){
				pline_The("medallion crumbles to dust!");
				if (uamul) useup(uamul);
			}
			else {
				remove_oprop(uamul, OPROP_LIFE);
			}
		}
		else if((otmp = find_equip_life_oprop())){
			Your("%s %s!",
				  xname(otmp),
				  !Blind ? "begins to glow" : "feels warm");
			if (how == CHOKING) You("vomit ...");
			if (how == DISINTEGRATED) You("reconstitute!");
			else if (how == OVERWOUND) You("reassemble!");
			else You_feel("much better!");

			lsvd = LSVD_MISC;
			remove_oprop(otmp, OPROP_LIFE);
		} else if(u.sealsActive&SEAL_JACK){
			lsvd = LSVD_JACK;
			unbind_lifesaving(SEAL_JACK);
		} else if(uleft && uleft->otyp == RIN_WISHES && uleft->spe > 0){
			lsvd = LSVD_MISC;
			You("wish that hadn't happened.");
			pline("A star flares on your left ring-finger!");
			uleft->spe--;
		} else if(uright && uright->otyp == RIN_WISHES && uright->spe > 0){
			lsvd = LSVD_MISC;
			You("wish that hadn't happened.");
			pline("A star flares on your right ring-finger!");
			uright->spe--;
		} else {
			lsvd = LSVD_NONE;
			impossible("Lifesaved with no amulet, ring, or Jack?");
		}
		u.gevurah += 4;//cheated death.

		(void) adjattrib(A_CON, -1, TRUE);
		if((Upolyd ? u.mhmax : u.uhpmax) < 10){
			if(u.uhprolled < 10){
				u.uhprolled = 10;	/* arbitrary */
				calc_total_maxhp();
			}
			if((Upolyd ? u.mhmax : u.uhpmax) < 10 && u.uhpmod < 0){
				u.uhpmod = 0;	/* arbitrary */
				calc_total_maxhp();
			}
			if((Upolyd ? u.mhmax : u.uhpmax) < 10 && u.uhpbonus < 0){
				u.uhpbonus = 0;	/* arbitrary */
				calc_total_maxhp();
			}
		}
		if(youmonst.movement < 12)
			youmonst.movement = 12;
		savelife(how);
		if (how == GENOCIDED)
			pline("Unfortunately you are still genocided...");
		else {
			killer = 0;
			killer_format = 0;
			char * llogstr;
			switch (lsvd)
			{
			case LSVD_MISC: llogstr = "averted death";
				break;
			case LSVD_JACK: llogstr = "averted death";
				break;
			case LSVD_DTHK: llogstr = "averted death by becoming a death knight";
				break;
			default:
				impossible("unhandled lsvd");
				llogstr = "averted death, somehow";
				break;
			}
			livelog_write_string(llogstr);
			return;
		}
	}
	else lsvd = LSVD_NONE;
	if ((
#ifdef WIZARD
			wizard ||
#endif
			discover) && (how <= GENOCIDED)) {
		if(yn("Die?") == 'y') goto die;
		pline("OK, so you don't %s.",
			(how == CHOKING) ? "choke" : "die");
		if(u.uhpmax <= 9){
			if(u.uhprolled < 10){
				u.uhprolled = 10;	/* arbitrary */
				calc_total_maxhp();
			}
			if(u.uhpmax < 10 && u.uhpmod < 0){
				u.uhpmod = 0;	/* arbitrary */
				calc_total_maxhp();
			}
			if(u.uhpmax < 10 && u.uhpbonus < 0){
				u.uhpbonus = 0;	/* arbitrary */
				calc_total_maxhp();
			}
		}
		savelife(how);
		u.gevurah += 4;//cheated death.
		killer = 0;
		killer_format = 0;
		return;
	}
#undef LSVD_NONE
#undef LSVD_MISC
#undef LSVD_JACK
#undef LSVD_DTHK

    /*
     *	The game is now over...
     */

die:
	program_state.gameover = 1;
	/* in case of a subsequent panic(), there's no point trying to save */
	program_state.something_worth_saving = 0;
#ifdef DUMP_LOG
	/* D: Grab screen dump right here */
        if (dump_fn[0]) {
            dump_init();
            if (dump_fp) {
                Sprintf(pbuf, "%s, %s %s %s %s", plname,
                        aligns[1 - u.ualign.type].adj,
                        genders[flags.female].adj,
                        urace.adj,
                        (flags.female && urole.name.f)?
                        urole.name.f : urole.name.m);
                dump("", pbuf);
				char vbuf[BUFSZ];
				(void) getversionstring(vbuf);
				Sprintf(pbuf, "Playing %s", vbuf);
				dump("", pbuf);
                /* D: Add a line for clearance from the screen dump */
	        dump("", "");
	        dump_screen(0);
            }
        }
#endif /* DUMP_LOG */

#ifdef WHEREIS_FILE
	delete_whereis();
#endif

	/* render vision subsystem inoperative */
	iflags.vision_inited = 0;
	/* might have been killed while using a disposable item, so make sure
	   it's gone prior to inventory disclosure and creation of bones data */
	inven_inuse(TRUE);
	{
		struct monst *mtmp;
		for (mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
			if(mtmp->mtyp == PM_OONA && mtmp->mtame)
				achieve.get_keys |= (1 << (ART_THIRD_KEY_OF_LAW - ART_FIRST_KEY_OF_LAW));
				
		}
	}
#ifdef RECORD_REALTIME
        /* Update the realtime counter to reflect the playtime of the current
         * game. */
        realtime_data.realtime = get_realtime();
#endif /* RECORD_REALTIME */

	/* Sometimes you die on the first move.  Life's not fair.
	 * On those rare occasions you get hosed immediately, go out
	 * smiling... :-)  -3.
	 */
	if (moves <= 1 && how < PANICKED)	/* You die... --More-- */
	    pline("Do not pass go.  Do not collect 200 %s.", currency(200L));

	if (have_windows) wait_synch();	/* flush screen output */
#ifndef NO_SIGNAL
	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
# if defined(UNIX) || defined(VMS) || defined (__EMX__)
	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
# endif
#endif /* NO_SIGNAL */

	bones_ok = (how < GENOCIDED) && can_make_bones();

	if (how == TURNED_SLIME)
	    u.ugrave_arise = PM_GREEN_SLIME;

	if (bones_ok && u.ugrave_arise < LOW_PM) {
	    /* corpse gets burnt up too */
	    if (how == BURNING)
		u.ugrave_arise = (NON_PM - 2);	/* leave no corpse */
	    else if (how == STONING)
		u.ugrave_arise = (NON_PM - 1);	/* statue instead of corpse */
	    else if (how == GOLDING)
		u.ugrave_arise = (NON_PM - 3);	/* statue instead of corpse */
	    else if (how == GLASSED)
		u.ugrave_arise = (NON_PM - 4);	/* statue instead of corpse */
	    else if (u.ugrave_arise == NON_PM &&
		     !(mvitals[u.umonnum].mvflags & G_NOCORPSE)) {
		int mtyp = u.umonnum;

		if (!Upolyd) {
		    /* Base corpse on race when not poly'd since original
		     * u.umonnum is based on role, and all role monsters
		     * are human.
		     */
		    mtyp = (flags.female && urace.femalenum != NON_PM) ?
			urace.femalenum : urace.malenum;
		}
		corpse = mk_named_object(CORPSE, &mons[mtyp],
				       u.ux, u.uy, plname);
		Sprintf(pbuf, "%s, %s%s", plname,
			killer_format == NO_KILLER_PREFIX ? "" :
			killed_by_prefix[how],
			killer_format == KILLED_BY_AN ? an(killer) : killer);
		make_grave(u.ux, u.uy, pbuf);
	    }
	}

	if (how == QUIT) {
		killer_format = NO_KILLER_PREFIX;
		if (u.uhp < 1) {
			how = DIED;
			u.umortality++;	/* skipped above when how==QUIT */
			/* note that killer is pointing at kilbuf */
			Strcpy(kilbuf, "quit while already on Charon's boat");
		}
	}
	if (how == ESCAPED || how == PANICKED)
		killer_format = NO_KILLER_PREFIX;

	if (how != PANICKED) {
	    /* these affect score and/or bones, but avoid them during panic */
	    taken = paybill((how == ESCAPED) ? -1 : (how != QUIT));
	    paygd();
	    clearpriests();
	} else	taken = FALSE;	/* lint; assert( !bones_ok ); */

	clearlocks();

	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);

	if (strcmp(flags.end_disclose, "none") && how != PANICKED) {
		disclose(how, taken);
#if defined(DUMP_LOG) && defined(DUMPMSGS)
		if (lastmsg >= 0) {
		  dump ("", "Latest messages");
		  for (i = lastmsg + 1; i < DUMPMSGS; i++) {
		    if (msgs[i] && strcmp(msgs[i], "") )
		      dump ("  ", msgs[i]);
		  } 
		  for (i = 0; i <= lastmsg; i++) {
		    if (msgs[i] && strcmp(msgs[i], "") )
		      dump ("  ", msgs[i]);
		  } 
		  dump ("","");
		}
#endif
	}
	/* finish_paybill should be called after disclosure but before bones */
	if (bones_ok && taken) finish_paybill();

	/* calculate score, before creating bones [container gold] */
	{
	    long tmp;
	    int deepest = deepest_lev_reached(FALSE);

#ifndef GOLDOBJ
	    umoney = u.ugold;
	    tmp = u.ugold0;
#else
	    umoney = money_cnt(invent);
	    tmp = u.umoney0;
#endif
	    umoney += hidden_gold();	/* accumulate gold from containers */
	    tmp = umoney - tmp;		/* net gain */

	    if (tmp < 0L)
		tmp = 0L;
	    if (how < PANICKED)
		tmp -= tmp / 10L;
	    u.urexp += tmp;
	    u.urexp += 50L * (long)(deepest - 1);
	    if (deepest > 20)
		u.urexp += 1000L * (long)((deepest > 30) ? 10 : deepest - 20);
	    if (how == ASCENDED && (!Role_if(PM_ANACHRONONAUT) || flags.questprogress==2)) u.urexp *= 2L;
	}

	if (bones_ok) {
#ifdef WIZARD
# ifdef PARANOID
	    if(wizard) {
		getlin("Save WIZARD MODE bones? [no/yes]", paranoid_buf);
		(void) lcase (paranoid_buf);
		if (strcmp (paranoid_buf, "yes"))
		  really_bon = FALSE;
            }
            if(really_bon)
# else
	    if (!wizard || yn("Save bones?") == 'y')
#endif /* PARANOID */
#endif /* WIZARD */
		savebones(corpse);
	    /* corpse may be invalid pointer now so
		ensure that it isn't used again */
	    corpse = (struct obj *)0;
	}

	/* update gold for the rip output, which can't use hidden_gold()
	   (containers will be gone by then if bones just got saved...) */
#ifndef GOLDOBJ
	u.ugold = umoney;
#else
	done_money = umoney;
#endif

	/* clean up unneeded windows */
	if (have_windows) {
	    wait_synch();
	    display_nhwindow(WIN_MESSAGE, TRUE);
	    destroy_nhwindow(WIN_MAP);
	    destroy_nhwindow(WIN_STATUS);
	    destroy_nhwindow(WIN_MESSAGE);
	    WIN_MESSAGE = WIN_STATUS = WIN_MAP = WIN_ERR;

	    if(!done_stopprint || flags.tombstone)
		endwin = create_nhwindow(NHW_TEXT);

	    if (how < GENOCIDED && flags.tombstone && endwin != WIN_ERR)
		outrip(endwin, how);
	} else
	    done_stopprint = 1; /* just avoid any more output */

/* changing kilbuf really changes killer. we do it this way because
   killer is declared a (const char *)
*/
	if (u.uhave.amulet) {
	    Strcat(kilbuf, " (with the Amulet)");
	    killer_flags |= 0x1;
	}
	else if (how == ESCAPED) {
	    if (Is_astralevel(&u.uz)) {	/* offered Amulet to wrong deity */
		Strcat(kilbuf, " (in celestial disgrace)");
		killer_flags |= 0x2;
	    } else if (carrying(FAKE_AMULET_OF_YENDOR)) {
		Strcat(kilbuf, " (with a fake Amulet)");
		killer_flags |= 0x4;
	    }
		/* don't bother counting to see whether it should be plural */
	}
	
	if(Role_if(PM_ANACHRONONAUT) && Is_astralevel(&u.uz)){
	    if (flags.questprogress!=2){
			if(how == ASCENDED) Strcat(kilbuf, ", but the future refused to change");
			else Strcat(kilbuf, ", and the future remained unchanged");
		} else {
			if(how == ASCENDED) Strcat(kilbuf, ", having saved the future");
			else Strcat(kilbuf, ", after completing the mission");
		}
	}

	    Sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
		   how != ASCENDED ?
		      (const char *) ((flags.female && urole.name.f) ?
		         urole.name.f : urole.name.m) :
		      (const char *) (flags.female ? "Demigoddess" : "Demigod"));
	if (!done_stopprint) {
	    putstr(endwin, 0, pbuf);
	    putstr(endwin, 0, "");
	}
#ifdef DUMP_LOG
	if (dump_fp) dump("", pbuf);
#endif

	if (how == ESCAPED || how == ASCENDED) {
	    register struct monst *mtmp;
	    register struct obj *otmp;
	    register struct val_list *val;
	    register int i;

	    for (val = valuables; val->list; val++)
		for (i = 0; i < val->size; i++) {
		    val->list[i].count = 0L;
		}
	    get_valuables(invent);

	    /* add points for collected valuables */
	    for (val = valuables; val->list; val++)
		for (i = 0; i < val->size; i++)
		    if (val->list[i].count != 0L)
			u.urexp += val->list[i].count
				  * (long)objects[val->list[i].typ].oc_cost;

	    /* count the points for artifacts */
	    artifact_score(invent, TRUE, endwin);

	    keepdogs(TRUE);
	    viz_array[0][0] |= IN_SIGHT; /* need visibility for naming */
	    mtmp = mydogs;
	    Strcpy(pbuf, "You");
	    if (mtmp) {
		while (mtmp) {
			if(Race_if(PM_ANDROID) && (mtmp->mtyp == PM_COMMANDER || mtmp->mtyp == PM_OPERATOR))
				give_rescue_trophy();
			Sprintf(eos(pbuf), " and %s", mon_nam(mtmp));
		    if (mtmp->mtame)
			u.urexp += mtmp->mhp;
		    mtmp = mtmp->nmon;
		}
		if (!done_stopprint) putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
		if (dump_fp) dump("", pbuf);
#endif
		pbuf[0] = '\0';
	    } else {
		if (!done_stopprint) Strcat(pbuf, " ");
	    }
		Sprintf(eos(pbuf), "%s with %ld point%s,",
			how==ASCENDED ? "went to your reward" :
					"escaped from the dungeon",
			u.urexp, plur(u.urexp));
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	    if (!done_stopprint) {
		putstr(endwin, 0, pbuf);
	    }

	    if (!done_stopprint)
		artifact_score(invent, FALSE, endwin);	/* list artifacts */
#ifdef DUMP_LOG
	    else
		artifact_score(invent, FALSE, WIN_ERR);
#endif
	    /* list valuables here */
	    for (val = valuables; val->list; val++) {
		sort_valuables(val->list, val->size);
		for (i = 0; i < val->size && !done_stopprint; i++) {
		    int typ = val->list[i].typ;
		    long count = val->list[i].count;

		    if (count == 0L) continue;
		    if (objects[typ].oc_class != GEM_CLASS || typ <= LAST_GEM) {
			otmp = mksobj(typ, MKOBJ_NOINIT);
			makeknown(otmp->otyp);
			otmp->known = 1;	/* for fake amulets */
			otmp->dknown = 1;	/* seen it (blindness fix) */
			otmp->quan = count;
			Sprintf(pbuf, "%8ld %s (worth %ld %s),",
				count, xname(otmp),
				count * (long)objects[typ].oc_cost, currency(2L));
			obfree(otmp, (struct obj *)0);
		    } else {
			Sprintf(pbuf,
				"%8ld worthless piece%s of colored glass,",
				count, plur(count));
		    }
		    putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
		    if (dump_fp) dump("", pbuf);
#endif
		}
	    }

	} else {
	    /* did not escape or ascend */
	    if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
		/* level teleported out of the dungeon; `how' is DIED,
		   due to falling or to "arriving at heaven prematurely" */
		Sprintf(pbuf, "You %s beyond the confines of the dungeon",
			(u.uz.dlevel < 0) ? "passed away" : ends[how]);
	    } else {
		/* more conventional demise */
		const char *where = dungeons[u.uz.dnum].dname;

		if (Is_astralevel(&u.uz)) where = "The Astral Plane";
		Sprintf(pbuf, "You %s in %s", ends[how], where);
		if (!In_endgame(&u.uz) && !Is_knox(&u.uz))
		    Sprintf(eos(pbuf), " on dungeon level %d",
			    In_quest(&u.uz) ? dunlev(&u.uz) : depth(&u.uz));
	    }

	    Sprintf(eos(pbuf), " with %ld point%s,",
		    u.urexp, plur(u.urexp));
	    if (!done_stopprint) putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	}

	    Sprintf(pbuf, "and %ld piece%s of gold, after %ld move%s.",
		    umoney, plur(umoney), moves, plur(moves));
	if (!done_stopprint)  putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
	if (dump_fp) {
	  dump("", pbuf);
	  Sprintf(pbuf, "Killer: %s", killer);
	  dump("", pbuf);
	}
#endif
	    Sprintf(pbuf,
	     "You were level %d with a maximum of %d hit point%s when you %s.",
		    u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
	if (!done_stopprint) {
	    putstr(endwin, 0, pbuf);
	    putstr(endwin, 0, "");
	}
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	if (!done_stopprint)
	    display_nhwindow(endwin, TRUE);
	if (endwin != WIN_ERR)
	    destroy_nhwindow(endwin);

	/* "So when I die, the first thing I will see in Heaven is a
	 * score list?" */
	if (flags.toptenwin) {
	    topten(how);
	    if (have_windows)
		exit_nhwindows((char *)0);
	} else {
	    if (have_windows)
		exit_nhwindows((char *)0);
	    topten(how);
	}
#ifdef DUMP_LOG
	if (dump_fp) dump_exit();
#endif

	if(done_stopprint) { raw_print(""); raw_print(""); }
	terminate(EXIT_SUCCESS);
}


void
container_contents(list, identified, all_containers)
struct obj *list;
boolean identified, all_containers;
#ifdef DUMP_LOG
{
	do_containerconts(list, identified, all_containers, FALSE, TRUE);
}

void do_containerconts(list, identified, all_containers, want_dump, want_disp)
struct obj *list;
boolean identified, all_containers, want_dump, want_disp;
#endif
/* The original container_contents function */
{
	register struct obj *box, *obj;
#ifdef SORTLOOT
	struct obj **oarray;
	int i,j,n;
	char *invlet;
#endif /* SORTLOOT */
	char buf[BUFSZ];

	for (box = list; box; box = box->nobj) {
	    if (Is_container(box) || box->otyp == STATUE) {
		if (box->otyp == BAG_OF_TRICKS) {
		    continue;	/* wrong type of container */
		} else if (box->cobj) {
		    winid tmpwin;
#ifdef DUMP_LOG
		    if (want_disp)
#endif
		    tmpwin = create_nhwindow(NHW_MENU);
#ifdef SORTLOOT
		    /* count the number of items */
		    for (n = 0, obj = box->cobj; obj; obj = obj->nobj) n++;
		    /* Make a temporary array to store the objects sorted */
		    oarray = (struct obj **) alloc(n*sizeof(struct obj*));

		    /* Add objects to the array */
		    i = 0;
		    invlet = flags.inv_order;
		nextclass:
		    for (obj = box->cobj; obj; obj = obj->nobj) {
                      if (!flags.sortpack || obj->oclass == *invlet) {
			if (iflags.sortloot == 'f'
			    || iflags.sortloot == 'l') {
			  /* Insert object at correct index */
			  for (j = i; j; j--) {
			    if (sortloot_cmp(obj, oarray[j-1])>0
			    || (flags.sortpack &&
				oarray[j-1]->oclass != obj->oclass))
			      break;
			    oarray[j] = oarray[j-1];
			  }
			  oarray[j] = obj;
			  i++;
			} else {
			  /* Just add it to the array */
			  oarray[i++] = obj;
			}
		      }
		    } /* for loop */
		    if (flags.sortpack) {
		      if (*++invlet) goto nextclass;
		    }
#endif /* SORTLOOT */
		    Sprintf(buf, "Contents of %s:", the(xname(box)));
#ifdef DUMP_LOG
		    if (want_disp) {
#endif
		    putstr(tmpwin, 0, buf);
		    putstr(tmpwin, 0, "");
#ifdef DUMP_LOG
		    }
		    if (dump_fp) dump("", buf);
#endif
#ifdef SORTLOOT
		    for (i = 0; i < n; i++) {
		      obj = oarray[i];
#else
		    for (obj = box->cobj; obj; obj = obj->nobj) {
#endif
			if (identified) {
			    makeknown(obj->otyp);
			    obj->known = obj->bknown =
			    obj->dknown = obj->rknown = obj->sknown = 1;
				if (obj->oartifact) discover_artifact(obj->oartifact);
			}
#ifdef DUMP_LOG
			if (want_dump)  dump("  ", doname(obj));
			if (want_disp)
#endif
			putstr(tmpwin, 0, doname(obj));
		    }
#ifdef DUMP_LOG
		    if (want_dump)  dump("","");
		    if (want_disp) {
#endif
		    display_nhwindow(tmpwin, TRUE);
		    destroy_nhwindow(tmpwin);
#ifdef DUMP_LOG
		    }
		    if (all_containers) {
			do_containerconts(box->cobj, identified, TRUE,
					  want_dump, want_disp);
#else
		    if (all_containers) {
			container_contents(box->cobj, identified, TRUE);
#endif /* DUMP_LOG */
		    }
		} else {
#ifdef DUMP_LOG
		    if (want_disp) {
#endif
		    pline("%s empty.", Tobjnam(box, "are"));
		    display_nhwindow(WIN_MESSAGE, FALSE);
#ifdef DUMP_LOG
		    }
		    if (want_dump) {
		      dump(The(xname(box)), " is empty.");
		      dump("", "");
		    }
#endif
		}
	    }
	    if (!all_containers)
		break;
	}
}


/* should be called with either EXIT_SUCCESS or EXIT_FAILURE */
void
terminate(status)
int status;
{
#ifdef MAC
	getreturn("to exit");
#endif
	/* don't bother to try to release memory if we're in panic mode, to
	   avoid trouble in case that happens to be due to memory problems */
	if (!program_state.panicking) {
	    freedynamicdata();
	    dlb_cleanup();
	}

	nethack_exit(status);
}

void		/* showborn patch */
list_vanquished(defquery, ask)
char defquery;
boolean ask;
#ifdef DUMP_LOG
{
  do_vanquished(defquery, ask, FALSE);
}

void
do_vanquished(defquery, ask, want_dump)
int defquery;
boolean ask;
boolean want_dump;
#endif
{
    register int i, lev;
    int ntypes = 0, max_lev = 0, nkilled;
    long total_killed = 0L;
    char c;
    winid klwin;
    char buf[BUFSZ];

    /* get totals first */
    for (i = LOW_PM; i < NUMMONS; i++) {
	if (mvitals[i].died) ntypes++;
	total_killed += (long)mvitals[i].died;
	if (mons[i].mlevel > max_lev) max_lev = mons[i].mlevel;
    }

    /* vanquished creatures list;
     * includes all dead monsters, not just those killed by the player
     */
    if (ntypes != 0) {
#ifdef DUMP_LOG
	c = done_stopprint ? 'n': ask ?
#else
	c = ask ?
#endif
	  yn_function("Do you want an account of creatures vanquished?",
			      ynqchars, defquery) : defquery;
	if (c == 'q') done_stopprint++;
	if (c == 'y') {
	    klwin = create_nhwindow(NHW_MENU);
	    putstr(klwin, 0, "Vanquished creatures:");
	    putstr(klwin, 0, "");
#ifdef DUMP_LOG
	} /* the original end of block removed by the patch */
	    if (want_dump)  dump("", "Vanquished creatures");
#endif

	    /* countdown by monster "toughness" */
	    for (lev = max_lev; lev >= 0; lev--)
	      for (i = LOW_PM; i < NUMMONS; i++)
		if (mons[i].mlevel == lev && (nkilled = mvitals[i].died) > 0) {
		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST) {
			Sprintf(buf, "%s%s",
				!type_is_pname(&mons[i]) ? "The " : "",
				mons[i].mname);
			if (nkilled > 1) {
			    switch (nkilled) {
				case 2:  Sprintf(eos(buf)," (twice)");  break;
				case 3:  Sprintf(eos(buf)," (thrice)");  break;
				default: Sprintf(eos(buf)," (%d time%s)",
						 nkilled, plur(nkilled));
					 break;
			    }
			}
		    } else {
			/* trolls or undead might have come back,
			   but we don't keep track of that */
			if (nkilled == 1)
			    Strcpy(buf, an(mons[i].mname));
			else
			    Sprintf(buf, "%d %s",
				    nkilled, makeplural(mons[i].mname));
#ifdef SHOW_BORN
			if (iflags.show_born && nkilled != mvitals[i].born)
			    Sprintf(buf + strlen(buf), " (%d created)",
				    (int) mvitals[i].born);
#endif
		    }
		    if (c == 'y') putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		    if (want_dump)  dump("  ", buf);
#endif
		}
	    /*
	     * if (Hallucination)
	     *     putstr(klwin, 0, "and a partridge in a pear tree");
	     */
	    if (ntypes > 1) {
		if (c == 'y') putstr(klwin, 0, "");
		Sprintf(buf, "%ld creatures vanquished.", total_killed);
		if (c == 'y') putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		if (want_dump)  dump("  ", buf);
#endif
	    }
	    if (c == 'y') {
	    display_nhwindow(klwin, TRUE);
	    destroy_nhwindow(klwin);
	}
#ifdef DUMP_LOG
	    if (want_dump)  dump("", "");
#else
	} /* the original end of if (c == 'y') */
#endif
    }
}

/* number of monster species which have been genocided */
int
num_genocides()
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
	if (mvitals[i].mvflags & G_GENOD) ++n;

    return n;
}

#ifdef DUMP_LOG
STATIC_OVL void
list_genocided(defquery, ask, want_dump)
int defquery;
boolean ask;
boolean want_dump;
#else
STATIC_OVL void
list_genocided(defquery, ask)
char defquery;
boolean ask;
#endif
{
    register int i;
    int ngenocided=0;
#ifdef SHOW_EXTINCT
    int nextincted=0;
#endif
    char c;
    winid klwin;
    char buf[BUFSZ];

    /* get totals first */
#ifdef SHOW_EXTINCT
    for (i = LOW_PM; i < NUMMONS; i++) {
	if (mvitals[i].mvflags & G_GENOD)
	    ngenocided++;
	else if ( (mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ) )
	    nextincted++;
    }
    ngenocided = num_genocides();
#endif

    /* genocided species list */
    if (ngenocided != 0
#ifdef SHOW_EXTINCT
      || nextincted != 0
#endif
    ) {
#ifdef SHOW_EXTINCT
	if (nextincted != 0)
	  c = ask ?
	  yn_function("Do you want a list of species genocided or extinct?",
		      ynqchars, defquery) : defquery;
       else
#endif
	c = ask ? yn_function("Do you want a list of species genocided?",
			      ynqchars, defquery) : defquery;
	if (c == 'q') done_stopprint++;
	if (c == 'y') {
	    klwin = create_nhwindow(NHW_MENU);
#ifdef SHOW_EXTINCT
	    Sprintf(buf, "Genocided or extinct species:");
#else
	    Sprintf(buf, "Genocided species:");
#endif
	    putstr(klwin, 0, buf);
	    putstr(klwin, 0, "");
#ifdef DUMP_LOG
	    if (want_dump)  dump("", buf);
#endif

	    for (i = LOW_PM; i < NUMMONS; i++)
#ifdef SHOW_EXTINCT
	      if (mvitals[i].mvflags & G_GONE && !(mons[i].geno & G_UNIQ) ){
#else
		if (mvitals[i].mvflags & G_GENOD) {
#endif
		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
			Sprintf(buf, "%s%s",
				!type_is_pname(&mons[i]) ? "" : "the ",
				mons[i].mname);
		    else
			Strcpy(buf, makeplural(mons[i].mname));
#ifdef SHOW_EXTINCT
		    if( !(mvitals[i].mvflags & G_GENOD) )
			Strcat(buf, " (extinct)");
#endif
		    putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		    if (want_dump)  dump("  ", buf);
#endif
		}

	    putstr(klwin, 0, "");
#ifdef SHOW_EXTINCT
	    if (ngenocided>0) {
#endif
	      Sprintf(buf, "%d species genocided.", ngenocided);
	      putstr(klwin, 0, buf);
#ifdef DUMP_LOG
	      if (want_dump)  dump("  ", buf);
#endif
#ifdef SHOW_EXTINCT
	    }
	    if (nextincted>0) {
	      Sprintf(buf, "%d species extinct.", nextincted);
	      putstr(klwin, 0, buf);
#ifdef DUMP_LOG
	      if (want_dump) dump(" ", buf);
#endif
            }
#endif /* SHOW_EXTINCT */
#ifdef DUMP_LOG
	      if (want_dump)  dump("", "");
#endif

	    display_nhwindow(klwin, TRUE);
	    destroy_nhwindow(klwin);
	}
    }
}

/*end.c*/
